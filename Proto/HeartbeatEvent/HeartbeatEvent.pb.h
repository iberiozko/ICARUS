// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HeartbeatEvent.proto

#ifndef PROTOBUF_HeartbeatEvent_2eproto__INCLUDED
#define PROTOBUF_HeartbeatEvent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_HeartbeatEvent_2eproto();
void protobuf_AssignDesc_HeartbeatEvent_2eproto();
void protobuf_ShutdownFile_HeartbeatEvent_2eproto();

class Hardware;
class HeartbeatEvent;

// ===================================================================

class Hardware : public ::google::protobuf::Message {
 public:
  Hardware();
  virtual ~Hardware();

  Hardware(const Hardware& from);

  inline Hardware& operator=(const Hardware& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hardware& default_instance();

  void Swap(Hardware* other);

  // implements Message ----------------------------------------------

  Hardware* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hardware& from);
  void MergeFrom(const Hardware& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sysname = 1;
  inline bool has_sysname() const;
  inline void clear_sysname();
  static const int kSysnameFieldNumber = 1;
  inline const ::std::string& sysname() const;
  inline void set_sysname(const ::std::string& value);
  inline void set_sysname(const char* value);
  inline void set_sysname(const char* value, size_t size);
  inline ::std::string* mutable_sysname();
  inline ::std::string* release_sysname();
  inline void set_allocated_sysname(::std::string* sysname);

  // required string nodename = 2;
  inline bool has_nodename() const;
  inline void clear_nodename();
  static const int kNodenameFieldNumber = 2;
  inline const ::std::string& nodename() const;
  inline void set_nodename(const ::std::string& value);
  inline void set_nodename(const char* value);
  inline void set_nodename(const char* value, size_t size);
  inline ::std::string* mutable_nodename();
  inline ::std::string* release_nodename();
  inline void set_allocated_nodename(::std::string* nodename);

  // required string release = 3;
  inline bool has_release() const;
  inline void clear_release();
  static const int kReleaseFieldNumber = 3;
  inline const ::std::string& release() const;
  inline void set_release(const ::std::string& value);
  inline void set_release(const char* value);
  inline void set_release(const char* value, size_t size);
  inline ::std::string* mutable_release();
  inline ::std::string* release_release();
  inline void set_allocated_release(::std::string* release);

  // required string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required string machine = 5;
  inline bool has_machine() const;
  inline void clear_machine();
  static const int kMachineFieldNumber = 5;
  inline const ::std::string& machine() const;
  inline void set_machine(const ::std::string& value);
  inline void set_machine(const char* value);
  inline void set_machine(const char* value, size_t size);
  inline ::std::string* mutable_machine();
  inline ::std::string* release_machine();
  inline void set_allocated_machine(::std::string* machine);

  // @@protoc_insertion_point(class_scope:Proto.Hardware)
 private:
  inline void set_has_sysname();
  inline void clear_has_sysname();
  inline void set_has_nodename();
  inline void clear_has_nodename();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_machine();
  inline void clear_has_machine();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sysname_;
  ::std::string* nodename_;
  ::std::string* release_;
  ::std::string* version_;
  ::std::string* machine_;
  friend void  protobuf_AddDesc_HeartbeatEvent_2eproto();
  friend void protobuf_AssignDesc_HeartbeatEvent_2eproto();
  friend void protobuf_ShutdownFile_HeartbeatEvent_2eproto();

  void InitAsDefaultInstance();
  static Hardware* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatEvent : public ::google::protobuf::Message {
 public:
  HeartbeatEvent();
  virtual ~HeartbeatEvent();

  HeartbeatEvent(const HeartbeatEvent& from);

  inline HeartbeatEvent& operator=(const HeartbeatEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatEvent& default_instance();

  void Swap(HeartbeatEvent* other);

  // implements Message ----------------------------------------------

  HeartbeatEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatEvent& from);
  void MergeFrom(const HeartbeatEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string guid = 1;
  inline bool has_guid() const;
  inline void clear_guid();
  static const int kGuidFieldNumber = 1;
  inline const ::std::string& guid() const;
  inline void set_guid(const ::std::string& value);
  inline void set_guid(const char* value);
  inline void set_guid(const char* value, size_t size);
  inline ::std::string* mutable_guid();
  inline ::std::string* release_guid();
  inline void set_allocated_guid(::std::string* guid);

  // required string systemName = 2;
  inline bool has_systemname() const;
  inline void clear_systemname();
  static const int kSystemNameFieldNumber = 2;
  inline const ::std::string& systemname() const;
  inline void set_systemname(const ::std::string& value);
  inline void set_systemname(const char* value);
  inline void set_systemname(const char* value, size_t size);
  inline ::std::string* mutable_systemname();
  inline ::std::string* release_systemname();
  inline void set_allocated_systemname(::std::string* systemname);

  // required string systemType = 3;
  inline bool has_systemtype() const;
  inline void clear_systemtype();
  static const int kSystemTypeFieldNumber = 3;
  inline const ::std::string& systemtype() const;
  inline void set_systemtype(const ::std::string& value);
  inline void set_systemtype(const char* value);
  inline void set_systemtype(const char* value, size_t size);
  inline ::std::string* mutable_systemtype();
  inline ::std::string* release_systemtype();
  inline void set_allocated_systemtype(::std::string* systemtype);

  // required string systemModel = 4;
  inline bool has_systemmodel() const;
  inline void clear_systemmodel();
  static const int kSystemModelFieldNumber = 4;
  inline const ::std::string& systemmodel() const;
  inline void set_systemmodel(const ::std::string& value);
  inline void set_systemmodel(const char* value);
  inline void set_systemmodel(const char* value, size_t size);
  inline ::std::string* mutable_systemmodel();
  inline ::std::string* release_systemmodel();
  inline void set_allocated_systemmodel(::std::string* systemmodel);

  // required .Proto.Hardware hardware = 5;
  inline bool has_hardware() const;
  inline void clear_hardware();
  static const int kHardwareFieldNumber = 5;
  inline const ::Proto::Hardware& hardware() const;
  inline ::Proto::Hardware* mutable_hardware();
  inline ::Proto::Hardware* release_hardware();
  inline void set_allocated_hardware(::Proto::Hardware* hardware);

  // @@protoc_insertion_point(class_scope:Proto.HeartbeatEvent)
 private:
  inline void set_has_guid();
  inline void clear_has_guid();
  inline void set_has_systemname();
  inline void clear_has_systemname();
  inline void set_has_systemtype();
  inline void clear_has_systemtype();
  inline void set_has_systemmodel();
  inline void clear_has_systemmodel();
  inline void set_has_hardware();
  inline void clear_has_hardware();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* guid_;
  ::std::string* systemname_;
  ::std::string* systemtype_;
  ::std::string* systemmodel_;
  ::Proto::Hardware* hardware_;
  friend void  protobuf_AddDesc_HeartbeatEvent_2eproto();
  friend void protobuf_AssignDesc_HeartbeatEvent_2eproto();
  friend void protobuf_ShutdownFile_HeartbeatEvent_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// Hardware

// required string sysname = 1;
inline bool Hardware::has_sysname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hardware::set_has_sysname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hardware::clear_has_sysname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hardware::clear_sysname() {
  if (sysname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_->clear();
  }
  clear_has_sysname();
}
inline const ::std::string& Hardware::sysname() const {
  // @@protoc_insertion_point(field_get:Proto.Hardware.sysname)
  return *sysname_;
}
inline void Hardware::set_sysname(const ::std::string& value) {
  set_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_ = new ::std::string;
  }
  sysname_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.Hardware.sysname)
}
inline void Hardware::set_sysname(const char* value) {
  set_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_ = new ::std::string;
  }
  sysname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.Hardware.sysname)
}
inline void Hardware::set_sysname(const char* value, size_t size) {
  set_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_ = new ::std::string;
  }
  sysname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.Hardware.sysname)
}
inline ::std::string* Hardware::mutable_sysname() {
  set_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sysname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Hardware.sysname)
  return sysname_;
}
inline ::std::string* Hardware::release_sysname() {
  clear_has_sysname();
  if (sysname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sysname_;
    sysname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Hardware::set_allocated_sysname(::std::string* sysname) {
  if (sysname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sysname_;
  }
  if (sysname) {
    set_has_sysname();
    sysname_ = sysname;
  } else {
    clear_has_sysname();
    sysname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Hardware.sysname)
}

// required string nodename = 2;
inline bool Hardware::has_nodename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hardware::set_has_nodename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hardware::clear_has_nodename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hardware::clear_nodename() {
  if (nodename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_->clear();
  }
  clear_has_nodename();
}
inline const ::std::string& Hardware::nodename() const {
  // @@protoc_insertion_point(field_get:Proto.Hardware.nodename)
  return *nodename_;
}
inline void Hardware::set_nodename(const ::std::string& value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.Hardware.nodename)
}
inline void Hardware::set_nodename(const char* value) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.Hardware.nodename)
}
inline void Hardware::set_nodename(const char* value, size_t size) {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  nodename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.Hardware.nodename)
}
inline ::std::string* Hardware::mutable_nodename() {
  set_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Hardware.nodename)
  return nodename_;
}
inline ::std::string* Hardware::release_nodename() {
  clear_has_nodename();
  if (nodename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nodename_;
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Hardware::set_allocated_nodename(::std::string* nodename) {
  if (nodename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nodename_;
  }
  if (nodename) {
    set_has_nodename();
    nodename_ = nodename;
  } else {
    clear_has_nodename();
    nodename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Hardware.nodename)
}

// required string release = 3;
inline bool Hardware::has_release() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hardware::set_has_release() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hardware::clear_has_release() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hardware::clear_release() {
  if (release_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_->clear();
  }
  clear_has_release();
}
inline const ::std::string& Hardware::release() const {
  // @@protoc_insertion_point(field_get:Proto.Hardware.release)
  return *release_;
}
inline void Hardware::set_release(const ::std::string& value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.Hardware.release)
}
inline void Hardware::set_release(const char* value) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.Hardware.release)
}
inline void Hardware::set_release(const char* value, size_t size) {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  release_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.Hardware.release)
}
inline ::std::string* Hardware::mutable_release() {
  set_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    release_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Hardware.release)
  return release_;
}
inline ::std::string* Hardware::release_release() {
  clear_has_release();
  if (release_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = release_;
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Hardware::set_allocated_release(::std::string* release) {
  if (release_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete release_;
  }
  if (release) {
    set_has_release();
    release_ = release;
  } else {
    clear_has_release();
    release_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Hardware.release)
}

// required string version = 4;
inline bool Hardware::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hardware::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hardware::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hardware::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Hardware::version() const {
  // @@protoc_insertion_point(field_get:Proto.Hardware.version)
  return *version_;
}
inline void Hardware::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.Hardware.version)
}
inline void Hardware::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.Hardware.version)
}
inline void Hardware::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.Hardware.version)
}
inline ::std::string* Hardware::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Hardware.version)
  return version_;
}
inline ::std::string* Hardware::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Hardware::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Hardware.version)
}

// required string machine = 5;
inline bool Hardware::has_machine() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hardware::set_has_machine() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hardware::clear_has_machine() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hardware::clear_machine() {
  if (machine_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_->clear();
  }
  clear_has_machine();
}
inline const ::std::string& Hardware::machine() const {
  // @@protoc_insertion_point(field_get:Proto.Hardware.machine)
  return *machine_;
}
inline void Hardware::set_machine(const ::std::string& value) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_ = new ::std::string;
  }
  machine_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.Hardware.machine)
}
inline void Hardware::set_machine(const char* value) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_ = new ::std::string;
  }
  machine_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.Hardware.machine)
}
inline void Hardware::set_machine(const char* value, size_t size) {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_ = new ::std::string;
  }
  machine_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.Hardware.machine)
}
inline ::std::string* Hardware::mutable_machine() {
  set_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    machine_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.Hardware.machine)
  return machine_;
}
inline ::std::string* Hardware::release_machine() {
  clear_has_machine();
  if (machine_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = machine_;
    machine_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Hardware::set_allocated_machine(::std::string* machine) {
  if (machine_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete machine_;
  }
  if (machine) {
    set_has_machine();
    machine_ = machine;
  } else {
    clear_has_machine();
    machine_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.Hardware.machine)
}

// -------------------------------------------------------------------

// HeartbeatEvent

// required string guid = 1;
inline bool HeartbeatEvent::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatEvent::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatEvent::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatEvent::clear_guid() {
  if (guid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_->clear();
  }
  clear_has_guid();
}
inline const ::std::string& HeartbeatEvent::guid() const {
  // @@protoc_insertion_point(field_get:Proto.HeartbeatEvent.guid)
  return *guid_;
}
inline void HeartbeatEvent::set_guid(const ::std::string& value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.HeartbeatEvent.guid)
}
inline void HeartbeatEvent::set_guid(const char* value) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.HeartbeatEvent.guid)
}
inline void HeartbeatEvent::set_guid(const char* value, size_t size) {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  guid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.HeartbeatEvent.guid)
}
inline ::std::string* HeartbeatEvent::mutable_guid() {
  set_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    guid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.HeartbeatEvent.guid)
  return guid_;
}
inline ::std::string* HeartbeatEvent::release_guid() {
  clear_has_guid();
  if (guid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = guid_;
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HeartbeatEvent::set_allocated_guid(::std::string* guid) {
  if (guid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete guid_;
  }
  if (guid) {
    set_has_guid();
    guid_ = guid;
  } else {
    clear_has_guid();
    guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.HeartbeatEvent.guid)
}

// required string systemName = 2;
inline bool HeartbeatEvent::has_systemname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatEvent::set_has_systemname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatEvent::clear_has_systemname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatEvent::clear_systemname() {
  if (systemname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemname_->clear();
  }
  clear_has_systemname();
}
inline const ::std::string& HeartbeatEvent::systemname() const {
  // @@protoc_insertion_point(field_get:Proto.HeartbeatEvent.systemName)
  return *systemname_;
}
inline void HeartbeatEvent::set_systemname(const ::std::string& value) {
  set_has_systemname();
  if (systemname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemname_ = new ::std::string;
  }
  systemname_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.HeartbeatEvent.systemName)
}
inline void HeartbeatEvent::set_systemname(const char* value) {
  set_has_systemname();
  if (systemname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemname_ = new ::std::string;
  }
  systemname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.HeartbeatEvent.systemName)
}
inline void HeartbeatEvent::set_systemname(const char* value, size_t size) {
  set_has_systemname();
  if (systemname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemname_ = new ::std::string;
  }
  systemname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.HeartbeatEvent.systemName)
}
inline ::std::string* HeartbeatEvent::mutable_systemname() {
  set_has_systemname();
  if (systemname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.HeartbeatEvent.systemName)
  return systemname_;
}
inline ::std::string* HeartbeatEvent::release_systemname() {
  clear_has_systemname();
  if (systemname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = systemname_;
    systemname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HeartbeatEvent::set_allocated_systemname(::std::string* systemname) {
  if (systemname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete systemname_;
  }
  if (systemname) {
    set_has_systemname();
    systemname_ = systemname;
  } else {
    clear_has_systemname();
    systemname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.HeartbeatEvent.systemName)
}

// required string systemType = 3;
inline bool HeartbeatEvent::has_systemtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatEvent::set_has_systemtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartbeatEvent::clear_has_systemtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartbeatEvent::clear_systemtype() {
  if (systemtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemtype_->clear();
  }
  clear_has_systemtype();
}
inline const ::std::string& HeartbeatEvent::systemtype() const {
  // @@protoc_insertion_point(field_get:Proto.HeartbeatEvent.systemType)
  return *systemtype_;
}
inline void HeartbeatEvent::set_systemtype(const ::std::string& value) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.HeartbeatEvent.systemType)
}
inline void HeartbeatEvent::set_systemtype(const char* value) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.HeartbeatEvent.systemType)
}
inline void HeartbeatEvent::set_systemtype(const char* value, size_t size) {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemtype_ = new ::std::string;
  }
  systemtype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.HeartbeatEvent.systemType)
}
inline ::std::string* HeartbeatEvent::mutable_systemtype() {
  set_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemtype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.HeartbeatEvent.systemType)
  return systemtype_;
}
inline ::std::string* HeartbeatEvent::release_systemtype() {
  clear_has_systemtype();
  if (systemtype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = systemtype_;
    systemtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HeartbeatEvent::set_allocated_systemtype(::std::string* systemtype) {
  if (systemtype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete systemtype_;
  }
  if (systemtype) {
    set_has_systemtype();
    systemtype_ = systemtype;
  } else {
    clear_has_systemtype();
    systemtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.HeartbeatEvent.systemType)
}

// required string systemModel = 4;
inline bool HeartbeatEvent::has_systemmodel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeartbeatEvent::set_has_systemmodel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeartbeatEvent::clear_has_systemmodel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeartbeatEvent::clear_systemmodel() {
  if (systemmodel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemmodel_->clear();
  }
  clear_has_systemmodel();
}
inline const ::std::string& HeartbeatEvent::systemmodel() const {
  // @@protoc_insertion_point(field_get:Proto.HeartbeatEvent.systemModel)
  return *systemmodel_;
}
inline void HeartbeatEvent::set_systemmodel(const ::std::string& value) {
  set_has_systemmodel();
  if (systemmodel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemmodel_ = new ::std::string;
  }
  systemmodel_->assign(value);
  // @@protoc_insertion_point(field_set:Proto.HeartbeatEvent.systemModel)
}
inline void HeartbeatEvent::set_systemmodel(const char* value) {
  set_has_systemmodel();
  if (systemmodel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemmodel_ = new ::std::string;
  }
  systemmodel_->assign(value);
  // @@protoc_insertion_point(field_set_char:Proto.HeartbeatEvent.systemModel)
}
inline void HeartbeatEvent::set_systemmodel(const char* value, size_t size) {
  set_has_systemmodel();
  if (systemmodel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemmodel_ = new ::std::string;
  }
  systemmodel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Proto.HeartbeatEvent.systemModel)
}
inline ::std::string* HeartbeatEvent::mutable_systemmodel() {
  set_has_systemmodel();
  if (systemmodel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    systemmodel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Proto.HeartbeatEvent.systemModel)
  return systemmodel_;
}
inline ::std::string* HeartbeatEvent::release_systemmodel() {
  clear_has_systemmodel();
  if (systemmodel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = systemmodel_;
    systemmodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void HeartbeatEvent::set_allocated_systemmodel(::std::string* systemmodel) {
  if (systemmodel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete systemmodel_;
  }
  if (systemmodel) {
    set_has_systemmodel();
    systemmodel_ = systemmodel;
  } else {
    clear_has_systemmodel();
    systemmodel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.HeartbeatEvent.systemModel)
}

// required .Proto.Hardware hardware = 5;
inline bool HeartbeatEvent::has_hardware() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeartbeatEvent::set_has_hardware() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeartbeatEvent::clear_has_hardware() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeartbeatEvent::clear_hardware() {
  if (hardware_ != NULL) hardware_->::Proto::Hardware::Clear();
  clear_has_hardware();
}
inline const ::Proto::Hardware& HeartbeatEvent::hardware() const {
  // @@protoc_insertion_point(field_get:Proto.HeartbeatEvent.hardware)
  return hardware_ != NULL ? *hardware_ : *default_instance_->hardware_;
}
inline ::Proto::Hardware* HeartbeatEvent::mutable_hardware() {
  set_has_hardware();
  if (hardware_ == NULL) hardware_ = new ::Proto::Hardware;
  // @@protoc_insertion_point(field_mutable:Proto.HeartbeatEvent.hardware)
  return hardware_;
}
inline ::Proto::Hardware* HeartbeatEvent::release_hardware() {
  clear_has_hardware();
  ::Proto::Hardware* temp = hardware_;
  hardware_ = NULL;
  return temp;
}
inline void HeartbeatEvent::set_allocated_hardware(::Proto::Hardware* hardware) {
  delete hardware_;
  hardware_ = hardware;
  if (hardware) {
    set_has_hardware();
  } else {
    clear_has_hardware();
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.HeartbeatEvent.hardware)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_HeartbeatEvent_2eproto__INCLUDED
